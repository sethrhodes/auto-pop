<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>auto-pop dev console</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        max-width: 900px;
        margin: 2rem auto;
        padding: 0 1rem 4rem;
        line-height: 1.5;
      }
      h1,
      h2 {
        margin-bottom: 0.25rem;
      }
      section {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin-bottom: 1.5rem;
      }
      label {
        display: block;
        margin: 0.5rem 0;
      }
      input[type="text"],
      input[type="number"],
      textarea {
        padding: 0.3rem 0.5rem;
        width: 100%;
        max-width: 280px;
      }
      input[type="file"] {
        margin-top: 0.25rem;
      }
      textarea {
        max-width: 100%;
      }
      button {
        padding: 0.4rem 0.9rem;
        margin-top: 0.75rem;
        cursor: pointer;
      }
      pre {
        background: #f6f6f6;
        padding: 0.75rem;
        border-radius: 6px;
        overflow-x: auto;
        font-size: 0.85rem;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }
      .col {
        flex: 1 1 260px;
        min-width: 0;
      }
      .thumb-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-top: 0.75rem;
      }
      .thumb {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        font-size: 0.8rem;
        max-width: 180px;
      }
      .thumb img {
        width: 100%;
        height: auto;
        border-radius: 4px;
        border: 1px solid #ddd;
        object-fit: cover;
      }
      small {
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>auto-pop dev console</h1>
    <p>
      End-to-end tester for your local backend:
      <code>/new-item</code>, <code>/analyze-tag</code>,
      <code>/generate-images</code>, and <code>/generate-copy</code>.
    </p>

    <!-- 1) Upload + create product -->
    <section>
      <h2>1. Upload images &amp; create Woo product</h2>
      <small>Calls <code>POST /new-item</code></small>

      <form id="new-item-form" enctype="multipart/form-data">
        <div class="row">
          <div class="col">
            <h3>Images</h3>
            <label>
              Front image (required)
              <input type="file" name="front" id="front" accept="image/*" />
            </label>
            <label>
              Back image (required)
              <input type="file" name="back" id="back" accept="image/*" />
            </label>
            <label>
              Tag image (optional, used for OCR)
              <input type="file" name="tag" id="tag" accept="image/*" />
            </label>
          </div>

          <div class="col">
            <h3>Product details</h3>
            <label>
              Name
              <input type="text" name="name" id="name" required />
            </label>
            <label>
              Price
              <input
                type="number"
                step="0.01"
                name="price"
                id="price"
                required
              />
            </label>
            <label>
              Quantity
              <input
                type="number"
                name="quantity"
                id="quantity"
                value="1"
                min="1"
              />
            </label>

            <button type="submit" id="create-btn">Create draft product</button>
          </div>
        </div>
      </form>

      <h3>Response from /new-item</h3>
      <pre id="new-item-result">Submit the form above to see response...</pre>

      <h3>Saved filenames (for AI)</h3>
      <pre id="filenames">front: -
back: -
tag: -</pre>

      <!-- OCR can run before or after product creation -->
      <button id="analyze-tag-btn">Analyze tag image (OCR)</button>

      <h3>Tag OCR result</h3>
      <pre id="tag-ocr-result">Tag OCR not run yet.</pre>
    </section>

    <!-- 2) Generate AI images -->
    <section>
      <h2>2. Generate on-model &amp; ghost images</h2>
      <small>Calls <code>POST /generate-images</code></small>

      <p>
        This uses the last saved <code>front</code> and
        <code>back</code> filenames from step 1.
      </p>

      <button id="generate-images-btn" disabled>Generate images</button>

      <h3>Raw response</h3>
      <pre id="generate-images-raw">Call /generate-images to see response...</pre>

      <h3>Rendered images</h3>
      <div id="generated-images" class="thumb-grid"></div>
      <small>
        Note: depending on your <code>imageGenClient.js</code> config, these may
        be Claid sample garments until you wire real garment URLs.
      </small>
    </section>

    <!-- 3) Generate product copy -->
    <section>
      <h2>3. Generate product copy</h2>
      <small>Calls <code>POST /generate-copy</code></small>

      <form id="copy-form">
        <div class="row">
          <div class="col">
            <h3>Inputs</h3>
            <label>
              Product type (e.g. "unisex heavyweight hoodie")
              <input type="text" id="copy-product-type" />
            </label>
            <label>
              Brand (optional)
              <input type="text" id="copy-brand" />
            </label>
            <label>
              Style notes (optional)
              <input
                type="text"
                id="copy-style-notes"
                placeholder="oversized fit, streetwear, etc."
              />
            </label>
          </div>

          <div class="col">
            <h3>Tag text</h3>
            <label>
              Raw tag text / garment info
              <textarea
                id="copy-tag-text"
                rows="6"
                placeholder="Paste tag text here or use 'Analyze tag' above to autofill..."
              ></textarea>
            </label>

            <button type="submit" id="copy-btn">Generate copy</button>
          </div>
        </div>
      </form>

      <h3>Copy output</h3>
      <pre id="copy-raw">Fill the form above to generate copy...</pre>

      <h3>Preview</h3>
      <div id="copy-preview"></div>
    </section>

    <script>
      const newItemForm = document.getElementById("new-item-form");
      const newItemResultEl = document.getElementById("new-item-result");
      const filenamesEl = document.getElementById("filenames");
      const createBtn = document.getElementById("create-btn");

      const generateBtn = document.getElementById("generate-images-btn");
      const genRawEl = document.getElementById("generate-images-raw");
      const genImagesContainer = document.getElementById("generated-images");

      const analyzeTagBtn = document.getElementById("analyze-tag-btn");
      const tagOcrResultEl = document.getElementById("tag-ocr-result");

      const nameInput = document.getElementById("name");
      const priceInput = document.getElementById("price");
      const tagInput = document.getElementById("tag");

      // Copy generation elements
      const copyForm = document.getElementById("copy-form");
      const copyBtn = document.getElementById("copy-btn");
      const copyTagTextEl = document.getElementById("copy-tag-text");
      const copyProductTypeEl = document.getElementById("copy-product-type");
      const copyBrandEl = document.getElementById("copy-brand");
      const copyStyleNotesEl = document.getElementById("copy-style-notes");
      const copyRawEl = document.getElementById("copy-raw");
      const copyPreviewEl = document.getElementById("copy-preview");

      let lastFrontFilename = null;
      let lastBackFilename = null;
      let lastTagFilename = null;

      // 1) Handle /new-item form submission
      newItemForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        newItemResultEl.textContent =
          "Uploading images and creating Woo product...";
        createBtn.disabled = true;

        const formData = new FormData(newItemForm);

        try {
          const res = await fetch("/new-item", {
            method: "POST",
            body: formData,
          });

          const data = await res.json();

          if (!res.ok) {
            newItemResultEl.textContent =
              "Error:\n" + JSON.stringify(data, null, 2);
            createBtn.disabled = false;
            return;
          }

          newItemResultEl.textContent = JSON.stringify(data, null, 2);

          // store filenames for later
          lastFrontFilename = data.images?.front || null;
          lastBackFilename = data.images?.back || null;
          lastTagFilename = data.images?.tag || null;

          filenamesEl.textContent = `front: ${
            lastFrontFilename || "-"
          }\nback: ${lastBackFilename || "-"}\ntag: ${lastTagFilename || "-"}`;

          // enable generate-images button if we have both front+back
          generateBtn.disabled = !(lastFrontFilename && lastBackFilename);
        } catch (err) {
          console.error(err);
          newItemResultEl.textContent = "Error: " + err.message;
        } finally {
          createBtn.disabled = false;
        }
      });

      // 2) Handle /generate-images
      generateBtn.addEventListener("click", async () => {
        if (!lastFrontFilename || !lastBackFilename) {
          alert("No front/back filenames available yet.");
          return;
        }

        generateBtn.disabled = true;
        generateBtn.textContent = "Generating...";

        genRawEl.textContent = "Calling /generate-images...";
        genImagesContainer.innerHTML = "";

        try {
          const res = await fetch("/generate-images", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              frontFilename: lastFrontFilename,
              backFilename: lastBackFilename,
            }),
          });

          const data = await res.json();

          if (!res.ok) {
            genRawEl.textContent =
              "Error:\n" + JSON.stringify(data, null, 2);
            return;
          }

          genRawEl.textContent = JSON.stringify(data, null, 2);

          genImagesContainer.innerHTML = "";
          const onModel = data.onModel || [];
          const ghost = data.ghost || [];

          onModel.forEach((img, idx) => {
            const div = document.createElement("div");
            div.className = "thumb";
            const imageEl = document.createElement("img");
            imageEl.src = img.url;
            imageEl.alt = `On-model ${idx + 1}`;

            const label = document.createElement("div");
            label.textContent = `On-model ${idx + 1}`;

            div.appendChild(imageEl);
            div.appendChild(label);
            genImagesContainer.appendChild(div);
          });

          ghost.forEach((img, idx) => {
            const div = document.createElement("div");
            div.className = "thumb";
            const imageEl = document.createElement("img");
            imageEl.src = img.url;
            imageEl.alt = `Ghost ${idx + 1}`;

            const label = document.createElement("div");
            label.textContent = `Ghost ${idx + 1}`;

            div.appendChild(imageEl);
            div.appendChild(label);
            genImagesContainer.appendChild(div);
          });
        } catch (err) {
          console.error(err);
          genRawEl.textContent = "Error: " + err.message;
        } finally {
          generateBtn.disabled = false;
          generateBtn.textContent = "Generate images";
        }
      });

      // 2b) Handle OCR: either use existing saved filename OR upload tag now
      analyzeTagBtn.addEventListener("click", async () => {
        const hasSavedTag = !!lastTagFilename;
        const tagFile = tagInput.files && tagInput.files[0];

        if (!hasSavedTag && !tagFile) {
          alert("Please select a tag image first.");
          return;
        }

        analyzeTagBtn.disabled = true;
        analyzeTagBtn.textContent = "Analyzing tag...";
        tagOcrResultEl.textContent = "Running OCR on tag image...";

        try {
          let data;

          if (hasSavedTag) {
            // Call /analyze-tag by filename
            const res = await fetch("/analyze-tag", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ tagFilename: lastTagFilename }),
            });
            data = await res.json();
            if (!res.ok) {
              tagOcrResultEl.textContent =
                "Error:\n" + JSON.stringify(data, null, 2);
              return;
            }
          } else {
            // Upload tag directly to /analyze-tag-upload
            const formData = new FormData();
            formData.append("tag", tagFile);

            const res = await fetch("/analyze-tag-upload", {
              method: "POST",
              body: formData,
            });
            data = await res.json();
            if (!res.ok) {
              tagOcrResultEl.textContent =
                "Error:\n" + JSON.stringify(data, null, 2);
              return;
            }

            // Save the filename returned by the server
            if (data.tagFilename) {
              lastTagFilename = data.tagFilename;
              filenamesEl.textContent = `front: ${
                lastFrontFilename || "-"
              }\nback: ${lastBackFilename || "-"}\ntag: ${lastTagFilename || "-"}`;
            }
          }

          // Show raw OCR text
          tagOcrResultEl.textContent = data.rawText || "(no text detected)";

          // Autofill tag text into copy generator
          if (data.rawText) {
            copyTagTextEl.value = data.rawText;
          }

          // Use parsed metadata (brand, productType, price) to fill fields
          if (data.parsed) {
            const parsed = data.parsed;

            // Fill Step 3 fields (copy generator)
            if (parsed.productType) {
              copyProductTypeEl.value = parsed.productType;
            }
            if (parsed.brand) {
              copyBrandEl.value = parsed.brand;
            }

            // Suggest a product name for Woo: "Brand ProductType"
            if (parsed.productType || parsed.brand) {
              const suggestedName = `${parsed.brand || ""} ${
                parsed.productType || ""
              }`.trim();
              if (suggestedName && !nameInput.value) {
                nameInput.value = suggestedName;
              }
            }

            // Fill price if parsed and empty
            if (parsed.price && !priceInput.value) {
              priceInput.value = parsed.price;
            }
          }
        } catch (err) {
          console.error(err);
          tagOcrResultEl.textContent = "Error: " + err.message;
        } finally {
          analyzeTagBtn.disabled = false;
          analyzeTagBtn.textContent = "Analyze tag image (OCR)";
        }
      });

      // 3) Handle /generate-copy submissions
      copyForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        copyBtn.disabled = true;
        copyBtn.textContent = "Generating...";

        copyRawEl.textContent = "Calling /generate-copy...";
        copyPreviewEl.innerHTML = "";

        const payload = {
          tagText: copyTagTextEl.value || "",
          productType: copyProductTypeEl.value || "",
          brand: copyBrandEl.value || "",
          styleNotes: copyStyleNotesEl.value || "",
        };

        try {
          const res = await fetch("/generate-copy", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          const data = await res.json();

          if (!res.ok) {
            copyRawEl.textContent =
              "Error:\n" + JSON.stringify(data, null, 2);
            return;
          }

          copyRawEl.textContent = JSON.stringify(data, null, 2);

          const title = data.title || "(no title)";
          const subtitle = data.subtitle || "";
          const description = data.description || "";
          const bullets = Array.isArray(data.bullets) ? data.bullets : [];
          const seo = Array.isArray(data.seo_keywords)
            ? data.seo_keywords
            : [];

          let html = "";
          html += `<h3>${escapeHtml(title)}</h3>`;
          if (subtitle) {
            html += `<p><em>${escapeHtml(subtitle)}</em></p>`;
          }
          if (description) {
            html += `<p>${escapeHtml(description)}</p>`;
          }
          if (bullets.length) {
            html += "<ul>";
            for (const b of bullets) {
              html += `<li>${escapeHtml(b)}</li>`;
            }
            html += "</ul>";
          }
          if (seo.length) {
            html += `<p><strong>SEO keywords:</strong> ${seo
              .map(escapeHtml)
              .join(", ")}</p>`;
          }

          copyPreviewEl.innerHTML = html || "<p>No copy generated.</p>";
        } catch (err) {
          console.error(err);
          copyRawEl.textContent = "Error: " + err.message;
        } finally {
          copyBtn.disabled = false;
          copyBtn.textContent = "Generate copy";
        }
      });

      // Helper: basic HTML escaping
      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
    </script>
  </body>
</html>